/*
 * THIS FILE WAS GENERATED BY "@atproto/lex". DO NOT EDIT.
 */

import { l } from '@atproto/lex'

const $nsid = 'org.openassociation.proposal'

export { $nsid }

/** Published requests or offers, sometimes with what is expected in return. */
type Main = {
  $type: 'org.openassociation.proposal'

  /**
   * The planned or actual beginning date, and time if desired, of a flow or process.
   */
  hasBeginning?: l.DatetimeString

  /**
   * The planned or actual ending date, and time if desired, of a flow or process.
   */
  hasEnd?: l.DatetimeString

  /**
   * This group of intents contains unit based quantities, which can be multipied to create commitments; commonly seen in a price list or e-commerce. Default false.
   */
  unitBased?: boolean

  /**
   * The type of proposal, whether offer or request (others may be added as need arises).
   */
  purpose?: 'offer' | 'request' | l.UnknownString

  /**
   * The date, and time if desired, the information was agreed to or recorded.
   */
  created?: l.DatetimeString

  /**
   * Location or area where the proposal is valid.
   */
  eligibleLocation?: Location

  /**
   * An informal or formal textual identifier for an object. Does not imply uniqueness.
   */
  name?: string

  /**
   * Any useful textual information related to the item.
   */
  note?: string

  /**
   * The primary intent(s) of this published proposal. Would be used in intent matching.
   */
  publishes?: l.AtUriString[]

  /**
   * The reciprocal intent(s) of this published proposal. Not meant to be used for intent matching.
   */
  reciprocal?: l.AtUriString[]

  /**
   * The agent(s) to which the proposal or proposal list is published.
   */
  proposedTo?: l.DidString[]

  /**
   * This proposal is part of these lists of proposals.
   */
  listedIn?: l.AtUriString[]
}

export type { Main }

/** Published requests or offers, sometimes with what is expected in return. */
const main = l.record<'tid', Main>(
  'tid',
  $nsid,
  l.object({
    hasBeginning: l.optional(l.string({ format: 'datetime' })),
    hasEnd: l.optional(l.string({ format: 'datetime' })),
    unitBased: l.optional(l.boolean()),
    purpose: l.optional(l.string()),
    created: l.optional(l.string({ format: 'datetime' })),
    eligibleLocation: l.optional(l.ref<Location>((() => location) as any)),
    name: l.optional(l.string({ maxGraphemes: 640 })),
    note: l.optional(l.string({ maxGraphemes: 10000 })),
    publishes: l.optional(l.array(l.string({ format: 'at-uri' }))),
    reciprocal: l.optional(l.array(l.string({ format: 'at-uri' }))),
    proposedTo: l.optional(l.array(l.string({ format: 'did' }))),
    listedIn: l.optional(l.array(l.string({ format: 'at-uri' }))),
  }),
)

export { main }

export const $isTypeOf = /*#__PURE__*/ main.isTypeOf.bind(main),
  $build = /*#__PURE__*/ main.build.bind(main),
  $type = /*#__PURE__*/ main.$type
export const $assert = /*#__PURE__*/ main.assert.bind(main),
  $check = /*#__PURE__*/ main.check.bind(main),
  $cast = /*#__PURE__*/ main.cast.bind(main),
  $ifMatches = /*#__PURE__*/ main.ifMatches.bind(main),
  $matches = /*#__PURE__*/ main.matches.bind(main),
  $parse = /*#__PURE__*/ main.parse.bind(main),
  $safeParse = /*#__PURE__*/ main.safeParse.bind(main),
  $validate = /*#__PURE__*/ main.validate.bind(main),
  $safeValidate = /*#__PURE__*/ main.safeValidate.bind(main)

type Location = {
  $type?: 'org.openassociation.proposal#location'

  /**
   * WGS84 latitude (decimal degrees).
   */
  lat?: string

  /**
   * WGS84 longitude (decimal degrees).
   */
  long?: string

  /**
   * WGS84 altitude (decimal meters above the local reference ellipsoid).
   */
  alt?: string

  /**
   * A textual address that can be mapped using mapping software.
   */
  mappableAddress?: string

  /**
   * An informal or formal textual identifier for the location.
   */
  name?: string
}

export type { Location }

const location = l.typedObject<Location>(
  $nsid,
  'location',
  l.object({
    lat: l.optional(l.string()),
    long: l.optional(l.string()),
    alt: l.optional(l.string()),
    mappableAddress: l.optional(l.string()),
    name: l.optional(l.string()),
  }),
)

export { location }
