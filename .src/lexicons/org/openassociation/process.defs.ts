/*
 * THIS FILE WAS GENERATED BY "@atproto/lex". DO NOT EDIT.
 */

import { l } from '@atproto/lex'

const $nsid = 'org.openassociation.process'

export { $nsid }

/** An activity that changes inputs into outputs, by transforming or transporting economic resource(s). */
type Main = {
  $type: 'org.openassociation.process'

  /**
   * All the input flows of a process.
   */
  hasInput?: l.AtUriString[]

  /**
   * All the output flows of a process.
   */
  hasOutput?: l.AtUriString[]

  /**
   * The process with its inputs and outputs, or the non-process commitment or intent, is part of the plan.
   */
  plannedWithin?: l.AtUriString

  /**
   * Scope here means executed in the context of an agent.
   */
  inScopeOf?: l.DidString

  /**
   * The planned or actual beginning date, and time if desired, of a flow or process.
   */
  hasBeginning?: l.DatetimeString

  /**
   * The planned or actual ending date, and time if desired, of a flow or process.
   */
  hasEnd?: l.DatetimeString

  /**
   * An informal or formal textual identifier for an object. Does not imply uniqueness.
   */
  name?: string

  /**
   * Any useful textual information related to the item.
   */
  note?: string

  /**
   * The commitment or intent or process is complete or not.  This is irrespective of if the original goal has been met, and indicates simply that no more will be done.  Default false.
   */
  finished?: boolean

  /**
   * The definition or standard specification for a process.
   */
  basedOn?: l.AtUriString

  /**
   * References one or more uri's for a concept in a common taxonomy or other classification scheme for purposes of categorization or grouping; or it can be one or more string classifications such as tags.
   */
  classifiedAs?: string[]
}

export type { Main }

/** An activity that changes inputs into outputs, by transforming or transporting economic resource(s). */
const main = l.record<'tid', Main>(
  'tid',
  $nsid,
  l.object({
    hasInput: l.optional(l.array(l.string({ format: 'at-uri' }))),
    hasOutput: l.optional(l.array(l.string({ format: 'at-uri' }))),
    plannedWithin: l.optional(l.string({ format: 'at-uri' })),
    inScopeOf: l.optional(l.string({ format: 'did' })),
    hasBeginning: l.optional(l.string({ format: 'datetime' })),
    hasEnd: l.optional(l.string({ format: 'datetime' })),
    name: l.optional(l.string({ maxGraphemes: 640 })),
    note: l.optional(l.string({ maxGraphemes: 10000 })),
    finished: l.optional(l.boolean()),
    basedOn: l.optional(l.string({ format: 'at-uri' })),
    classifiedAs: l.optional(l.array(l.string())),
  }),
)

export { main }

export const $isTypeOf = /*#__PURE__*/ main.isTypeOf.bind(main),
  $build = /*#__PURE__*/ main.build.bind(main),
  $type = /*#__PURE__*/ main.$type
export const $assert = /*#__PURE__*/ main.assert.bind(main),
  $check = /*#__PURE__*/ main.check.bind(main),
  $cast = /*#__PURE__*/ main.cast.bind(main),
  $ifMatches = /*#__PURE__*/ main.ifMatches.bind(main),
  $matches = /*#__PURE__*/ main.matches.bind(main),
  $parse = /*#__PURE__*/ main.parse.bind(main),
  $safeParse = /*#__PURE__*/ main.safeParse.bind(main),
  $validate = /*#__PURE__*/ main.validate.bind(main),
  $safeValidate = /*#__PURE__*/ main.safeValidate.bind(main)
